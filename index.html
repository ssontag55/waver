<!DOCTYPE html>
<meta charset="utf-8">

<script src="js/d3.v3.min.js"></script>
<script src="js/topojson.v1.min.js"></script>
<script src="js/three.min.js"></script>
<script src="data/wave_northamerica_sm.js"></script>
<link rel="stylesheet" href="csss/styling.css">

<html>
<body>
  <input type="button" id='stopbut' value="Stop" style=" width: 50px; " onclick="stopstartTimer()" />
  <b>Wave Watch 3: </b>
  <input type="text" id='tme' />
  <b>Number of Points: 8,206</b>
</body>
</html>
<script>

var numofwaveintervals = 11;
var camera, scene, renderer;
var width = 960,
    fullPage = '100%',
    height = 960;
    topx= 1600,
    lefty= 700,
    scale0 = 2200  / Math.PI;
var projection = d3.geo.mercator();

//Range of Color for wave height
var colour = d3.scale.linear()
                //this effects the range of the data 
                //and the visualization of the color gradient
                .domain([0, 1400])
                .range(["lightblue", "red"]);

//cycle through wave time data
var looper=setInterval(function(){loopTimer()},700);

//zoom inggg
var zoom = d3.behavior.zoom()
    .translate([topx, lefty])
    .scale(scale0)
    //.scaleExtent([scale0-5, 4000 * scale0-1])
    .on("zoom", zoomed);

var path = d3.geo.path()
    .projection(projection);

var svg = d3.select("body").append("svg")
    //.attr("width", d3.select("body").width)
    //.attr("height", d3.select("body").height)
  .append("g");

svg
    .call(zoom)
    .call(zoom.event);

//variable to set wave data source (time)
var waveData = wavepts0;

//d3.json("data/land/world-50m.txt", function(error, world) {
d3.json("data/land/world-110m.txt", function(error, world) {
  svg.append("path")
      .datum({type: "Sphere"})
      .attr("class", "sphere")
      .attr("d", path);

  svg.append("path")
      .datum(topojson.merge(world, world.objects.countries.geometries))
      .attr("class", "land")
      .attr("d", path);

  svg.append("path")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
      .attr("class", "boundary")
      .attr("d", path);
  
  //throw the points on the map  after for ordering purposes
  svg.selectAll(".pin")
    .data(waveData)
  .enter().append("circle")
    .attr("r", 2)
    .attr("fill", function(d){return d?colour(d[3]*500):"black";})
    .attr("stroke", function(d){return d?colour(d[3]*500):"black";})
    .attr("transform", function(d) {
      return "translate(" + projection([
        d[2],
        d[1]
      ]) + ")"
    })

});

//update wavedata
var loopinterval = 0;
function loopTimer() {
    loopinterval = loopinterval+1;
    //newwavedata = 'wavepts'+loopinterval
    waveData = this.window['wavepts'+loopinterval];
    
    //this depends on the number of time intervals.
    if(loopinterval>numofwaveintervals){
      loopinterval=0;
    }
    

    svg.selectAll('circle').remove();
    svg.selectAll(".pin")
      .data(waveData)
      .enter().append("circle")
      .attr("r", 2)
      .attr("fill", function(d){return d?colour(d[3]*500):"black";})
      .attr("stroke", function(d){return d?colour(d[3]*500):"black";})
      .attr("transform", function(d) {
        //text date
        document.getElementById("tme").value = d[0];
        return "translate(" + projection([
          d[2],
          d[1]
        ]) + ")"
      })
}

function stopstartTimer(){
  if(document.getElementById("stopbut").value == 'Stop'){
    clearInterval(looper);
    document.getElementById("stopbut").value = 'Start';
  }
  else{
    looper=setInterval(function(){loopTimer()},700);
    document.getElementById("stopbut").value = 'Stop';
  }

}

//map zoom control
function zoomed() {
  projection
      .translate(zoom.translate())
      .scale(zoom.scale());

  svg.selectAll("path")
      .attr("d", path);

  svg.selectAll("circle")
     //preserve color range
    .attr("fill", function(d){return d?colour(d[3]*500):"black";})
    .attr("stroke", function(d){return d?colour(d[3]*500):"black";})
    
    .attr("transform", function(d) {  
      return "translate(" + projection([
        d[2],
        d[1]
      ]) + ")"
    })
}

//start webGL scene
function initScene() {
    
    // set the scene size
    var WIDTH = 600, HEIGHT = 600;

    // set some camera attributes
    var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.1, FAR = 10000;

    // create a WebGL renderer, camera, and a scene
    renderer = new THREE.WebGLRenderer({antialias:true});
    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT,NEAR, FAR);
    scene = new THREE.Scene();

    // add and position the camera at a fixed position
    scene.add(camera);
    camera.position.z = 550;
    camera.position.x = 0;
    camera.position.y = 550;
    camera.lookAt( scene.position );

    // start the renderer, and black background
    renderer.setSize(WIDTH, HEIGHT);
    renderer.setClearColor(0x000);

    // add the render target to the page
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    // add a light at a specific position
    /*var pointLight = new THREE.PointLight(0xFFFFFF);
    scene.add(pointLight);
    pointLight.position.x = 800;
    pointLight.position.y = 800;
    pointLight.position.z = 800;*/

    var PI2 = Math.PI * 2;
    var material = new THREE.SpriteCanvasMaterial( {

          color: 0xffffff,
          program: function ( context ) {

            context.beginPath();
            context.arc( 0, 0, 0.5, 0, PI2, true );
            context.fill();
          }
    } );
    
    var SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

    particles = new Array();
    var i = 0;
    for ( var iy = 0; iy < wavepts0.length; iy ++ ) {

        particle = particles[ i ++ ] = new THREE.Sprite( material );
        particle.position.x = wavepts0[iy][1] * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
        particle.position.y = wavepts0[iy][2] * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
        particle.position.z = wavepts0[iy][3] * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
        scene.add( particle );

    }

    // add a base plane on which we'll render our map
    var planeGeo = new THREE.PlaneGeometry(10000, 10000, 10, 10);
    var planeMat = new THREE.MeshLambertMaterial({color: 0x666699});
    var plane = new THREE.Mesh(planeGeo, planeMat);

    // rotate it to correct position
    //plane.rotation.x = -Math.PI/2;
    //scene.add(plane);
    renderer.render( scene, camera );
}

function addGeoObject() {
    // keep track of rendered objects
    var meshes = [];
    var averageValues = [];
    var totalValues = [];

    // keep track of min and max, used to color the objects
    var maxValueAverage = 0;
    var minValueAverage = -1;

    // keep track of max and min of total value
    var maxValueTotal = 0;
    var minValueTotal = -1;

    // convert to mesh and calculate values
    for (var i = 0 ; i < wavepts0.length ; i++) {
        var geoFeature = wavepts0[i];
        var feature = geo.point(geoFeature);
        // we only need to convert it to a three.js path
        var mesh = transformSVGPathExposed(feature);
        // add to array
        meshes.push(mesh);

        // we get a property from the json object and use it
        // to determine the color later on
        var value = parseInt(geoFeature.properties.bev_dichth);
        if (value > maxValueAverage) maxValueAverage = value;
        if (value < minValueAverage || minValueAverage == -1) minValueAverage = value;
        averageValues.push(value);

        // and we get the max values to determine height later on.
        value = parseInt(geoFeature.properties.aant_inw);
        if (value > maxValueTotal) maxValueTotal = value;
        if (value < minValueTotal || minValueTotal == -1) minValueTotal = value;

        totalValues.push(value);
    }

    // we've got our paths now extrude them to a height and add a color
    for (var i = 0 ; i < averageValues.length ; i++) {

        // create material color based on average
        var scale = ((averageValues[i] - minValueAverage) / (maxValueAverage - minValueAverage)) * 255;
        var mathColor = gradient(Math.round(scale),255);
        var material = new THREE.MeshLambertMaterial({
            color: mathColor
        });

        // create extrude based on total
        var extrude = ((totalValues[i] - minValueTotal) / (maxValueTotal - minValueTotal)) * 100;
        var shape3d = meshes[i].extrude({amount: Math.round(extrude), bevelEnabled: false});

        // create a mesh based on material and extruded shape
        var toAdd = new THREE.Mesh(shape3d, material);

        // rotate and position the elements nicely in the center
        toAdd.rotation.x = Math.PI/2;
        toAdd.translateX(-490);
        toAdd.translateZ(50);
        toAdd.translateY(extrude/2);

        // add to scene
        scene.add(toAdd);
    }
  }

  // simple gradient function
  function gradient(length, maxLength) {

      var i = (length * 255 / maxLength);
      var r = i;
      var g = 255-(i);
      var b = 0;

      var rgb = b | (g << 8) | (r << 16);
      return rgb;
  }


//Let's gooo0
//initScene();
//addGeoObject();

</script>